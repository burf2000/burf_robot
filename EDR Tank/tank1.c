#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1, sonarSensorRight, sensorSONAR_cm)
#pragma config(Sensor, dgtl3, sonarSensorLeft, sensorSONAR_cm)
#pragma config(Sensor, dgtl12, touchSensor, sensorTouch)
#pragma config(Sensor, I2C_1, leftEncoder, sensorQuadEncoderOnI2CPort, , AutoAssign)
#pragma config(Sensor, I2C_2, rightEncoder, sensorQuadEncoderOnI2CPort, , AutoAssign)
#pragma config(Motor, port1, light1, tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor, port2, motor2, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port3, motor3, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port4, motor4, tmotorVex393_MC29, openLoop)
#pragma config(Motor, port5, motor5, tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor, port6, motor6, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor, port7, motor7, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor, port8, motor8, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor, port9, motor9, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor, port10, light2, tmotorVexFlashlight, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "BNSlib_HC05.h"

int DISTANCE = 20;

task sendReceiveData
{

	int a = 0;

	string sendString;
	char returnData[100];

	int leftMotorVal, rightMotorVal;

	while (SensorValue(touchSensor) == 0)
	{

		if (SensorValue(sonarSensorLeft) > DISTANCE && SensorValue(sonarSensorRight) > DISTANCE)
		{
			a += 1;
			stringFormat(sendString, "%d,%d.%d,%d", SensorValue(sonarSensorLeft), SensorValue(sonarSensorRight), nMotorEncoder[motor6], nMotorEncoder[motor5]);

			// Send Data
			bnsSerialSend(UART1, sendString);
			// send this to finish the line
			bnsSerialSend(UART1, "\n");

			// ReceiveData
			bnsSerialRead(UART1, returnData, 100, 100);

			sscanf(returnData, "%d %d", &leftMotorVal, &rightMotorVal);
			writeDebugStreamLine("motors %d %d" , leftMotorVal, rightMotorVal );
			//writeDebugStreamLine(returnData);

		}

		delay(100);
	}
}

task main()
{

	// This should match what the AT command set the baudrate to!
	setBaudRate(UART1, baudRate57600);
	startTask(sendReceiveData);

	motor[light1] = 127;
	motor[light2] = 127;

	//Clear the encoders associated with the left and right motors
	nMotorEncoder[motor5] = 0;
	nMotorEncoder[motor6] = 0;

	while (SensorValue(touchSensor) == 0)
	{

		if (SensorValue(sonarSensorLeft) > DISTANCE && SensorValue(sonarSensorRight) > DISTANCE)
		{
			// still allow joystick
			motor[motor2]  = 0 - (vexRT[Ch3]);
			motor[motor3]  = 0 - (vexRT[Ch3]);
			motor[motor4]  = 0 - (vexRT[Ch3]);
			motor[motor5]  = 0 - (vexRT[Ch3]);

			motor[motor6]  = 0 - (vexRT[Ch2]);
			motor[motor7]  = 0 - (vexRT[Ch2]);
			motor[motor8]  = 0 - (vexRT[Ch2]);
			motor[motor9]  = 0 - (vexRT[Ch2]);

		}
		else if (vexRT[Ch3] < 0 && vexRT[Ch2] < 0){
			motor[motor2]  = 0 - (vexRT[Ch3]);
			motor[motor3]  = 0 - (vexRT[Ch3]);
			motor[motor4]  = 0 - (vexRT[Ch3]);
			motor[motor5]  = 0 - (vexRT[Ch3]);

			motor[motor6]  = 0 - (vexRT[Ch2]);
			motor[motor7]  = 0 - (vexRT[Ch2]);
			motor[motor8]  = 0 - (vexRT[Ch2]);
			motor[motor9]  = 0 - (vexRT[Ch2]);
		}
		else {
			motor[motor2]  = 0;
			motor[motor3]  = 0;
			motor[motor4]  = 0;
			motor[motor5]  = 0;

			motor[motor6]  = 0;
			motor[motor7]  = 0;
			motor[motor8]  = 0;
			motor[motor9]  = 0;
		}

		/*

		*/
		/*
		writeDebugStreamLine("pad %f" ,vexRT[Ch3]);
		writeDebugStreamLine("right %f" , nMotorEncoder[motor5]);
		writeDebugStreamLine("Left sonar %f" , SensorValue(sonarSensorLeft));
		writeDebugStreamLine("Right sonar %f" , SensorValue(sonarSensorRight));
		writeDebugStreamLine("left %f" , nMotorEncoder[motor6]);
		*/
	}

	motor[light1] = 0;
	motor[light2] = 0;
}
